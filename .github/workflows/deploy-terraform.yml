name: ðŸš€ CI & Deploy with Dynamic Terraform Outputs

on:
  push:
    branches: [ main ]

jobs:
  # â”€â”€â”€ 1) Run your tests â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  test:
    name: ðŸ§ª Test
    runs-on: ubuntu-latest
    strategy:
      matrix:
        dir: [node, react]

    steps:
      - uses: actions/checkout@v3

      - name: Use Node.js
        uses: actions/setup-node@v3
        with: { node-version: '20' }

      - name: Install & test `${{ matrix.dir }}`
        working-directory: ${{ matrix.dir }}
        run: |
          npm install
          npm test

  # â”€â”€â”€ 2) Deploy to Terraform-managed infrastructure â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  deploy:
    name: ðŸš€ Deploy to Terraform EC2
    needs: test
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      # â€”â€”â€” 2.1 Configure AWS credentials â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-west-1

      # â€”â€”â€” 2.2 Get server IP from AWS (dynamic discovery) â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      - name: Get server IP from AWS
        id: terraform
        run: |
          # Find EC2 instance by tags (created by Terraform)
          INSTANCE_IP=$(aws ec2 describe-instances \
            --region eu-west-1 \
            --filters \
              "Name=tag:Project,Values=ecommerce-app" \
              "Name=tag:Environment,Values=production" \
              "Name=instance-state-name,Values=running" \
            --query 'Reservations[0].Instances[0].PublicIpAddress' \
            --output text)
          
          if [ -z "$INSTANCE_IP" ] || [ "$INSTANCE_IP" = "null" ] || [ "$INSTANCE_IP" = "None" ]; then
            echo "âŒ Could not find running EC2 instance with the right tags"
            echo "Looking for Project=ecommerce-app, Environment=production"
            exit 1
          fi
          
          echo "ðŸŽ¯ Found server IP: $INSTANCE_IP"
          echo "instance_ip=$INSTANCE_IP" >> $GITHUB_OUTPUT

      # â€”â€”â€” 2.3 Install SSH key â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      - name: Install SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

      # â€”â€”â€” 2.4 Add EC2 to known_hosts â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      - name: Add EC2 to known_hosts
        run: |
          echo "ðŸ” Adding host key for ${{ steps.terraform.outputs.instance_ip }}"
          mkdir -p ~/.ssh
          ssh-keyscan ${{ steps.terraform.outputs.instance_ip }} >> ~/.ssh/known_hosts

      # â€”â€”â€” 2.5 Deploy to Terraform-managed EC2 â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      - name: Deploy to EC2
        env:
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
        run: |
          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o ConnectTimeout=10 \
            ubuntu@${{ steps.terraform.outputs.instance_ip }} "export DB_PASSWORD='${DB_PASSWORD}' && bash -s" << 'EOF'
            
            set -e
            cd ~/Web3

            # Make deploy script executable and run it
            chmod +x ./deploy.sh
            ./deploy.sh

            echo "ðŸ§¹ Cleaning up old Docker resources..."
            docker image prune -f
            docker container prune -f
            docker network prune -f
            docker volume prune -f

            echo "â³ Waiting for services to start..."
            sleep 10  # Give services time to initialize

            echo "Checking if services are running..."
            docker compose -f docker-compose.prod.yml ps

            # Simple check to see if containers are running
            if ! docker compose -f docker-compose.prod.yml ps | grep -q "backend.*Up"; then
              echo "âŒ Backend container is not running!"
              docker compose -f docker-compose.prod.yml logs backend
              exit 1
            fi
            
            echo "Found containers:"
            echo "DB: $DB_CONTAINER"
            echo "Backend: $BACKEND_CONTAINER"
            echo "Proxy: $PROXY_CONTAINER"
            
            # Wait for MySQL to be ready
            echo "Checking MySQL..."
            for i in {1..30}; do
              if docker exec $DB_CONTAINER mysqladmin ping -h localhost -u root -p${DB_PASSWORD} --silent; then
                echo "âœ… MySQL is ready"
                break
              fi
              if [ $i -eq 30 ]; then
                echo "âŒ MySQL failed to start! Showing logs:"
                docker logs $DB_CONTAINER
                exit 1
              fi
              echo "Waiting for MySQL... (attempt $i/30)"
              sleep 5
            done

            # Give backend some time to start after MySQL is ready
            echo "Giving backend time to initialize..."
            sleep 10

            # Wait for the backend to be ready
            echo "Checking Backend..."
            for i in {1..30}; do
              if docker exec $BACKEND_CONTAINER wget -q --spider http://localhost:3000/api/health; then
                echo "âœ… Backend API is ready"
                break
              fi
              if [ $i -eq 30 ]; then
                echo "âŒ Backend health check failed! Showing logs:"
                echo "=== Backend Logs ==="
                docker logs $BACKEND_CONTAINER
                echo "=== MySQL Logs ==="
                docker logs $DB_CONTAINER
                exit 1
              fi
              echo "Waiting for Backend API... (attempt $i/30)"
              sleep 5
            done

            # Finally check if the proxy is working
            echo "Checking Proxy..."
            for i in {1..15}; do
              if curl -sf --connect-timeout 5 http://localhost/api/health; then
                echo "âœ… Proxy is ready"
                break
              fi
              if [ $i -eq 15 ]; then
                echo "âŒ Proxy health check failed! Showing logs:"
                docker logs $PROXY_CONTAINER
                exit 1
              fi
              echo "Waiting for Proxy... (attempt $i/15)"
              sleep 5
            done

            echo "âœ… Deployment complete and healthy!"
            echo "ðŸ“Š Docker space usage after cleanup:"
            docker system df
            
            echo "ðŸŽ‰ Deployment successful at $(date)"
          EOF

      # â€”â€”â€” 2.6 Notify on failure â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      - name: Notify on deployment failure
        if: failure()
        run: |
          echo "âŒ Deployment failed! Check the logs above for details."
